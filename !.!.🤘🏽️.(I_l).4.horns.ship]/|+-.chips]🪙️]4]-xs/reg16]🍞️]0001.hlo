

#🗓️REGISTER = (do the 16 input (with the numbers "AFTER register 1 or w/e ;) 
#🗓️

#🔘️#🔘️#🔘️#🔘️#🔘️
#clock	= 16
0000 0111, 0000 0111, 0000 0011 0000 0011
#switch_0 = 17
0000 0101, 0000 0101,0000 0011 0000 0011
#
#switch_1 = 18
0000 0110, 0000 0110, 0000 0011 0000 0011

#we will always fill these by default or leave mt same diff
#🔘️#🔘️#🔘️#🔘️#🔘️
#CLI 3

#0000 0011 0000 00110000 0011,0000 0101
#0000 0011 0000 00110000 0011,0000 0110
#0000 0011 0000 00110000 0011,0000 0111
########################################
#®️®️®️®️ ®️®️®️®️ ®️®️®️®️ ®️®️®️®️]16
#REGISTER 
#CHIP Register {
#    IN in[16], load;
#    OUT out[16];

#    PARTS:
#    Bit(in=in[0], load=load, out=out[0]);
#    Bit(in=in[1], load=load, out=out[1]);
#    Bit(in=in[2], load=load, out=out[2]);
#    Bit(in=in[3], load=load, out=out[3]);
#    Bit(in=in[4], load=load, out=out[4]);
#    Bit(in=in[5], load=load, out=out[5]);
#    Bit(in=in[6], load=load, out=out[6]);
#    Bit(in=in[7], load=load, out=out[7]);
#    Bit(in=in[8], load=load, out=out[8]);
#    Bit(in=in[9], load=load, out=out[9]);
#    Bit(in=in[10], load=load, out=out[10]);
#    Bit(in=in[11], load=load, out=out[11]);
#    Bit(in=in[12], load=load, out=out[12]);
#    Bit(in=in[13], load=load, out=out[13]);
#    Bit(in=in[14], load=load, out=out[14]);
#    Bit(in=in[15], load=load, out=out[15]);
#}
#

#BIT1#1️⃣️0000
#🪣️ 0001 0011 < 0001 0100
#🍄️
#MUX1 START


#/**
# * Multiplexor:
# * out = a if sel == 0
# *       b otherwise
# */

#CHIP Mux {
#    IN a, b, sel;
#    OUT out;

#####################
#(last number [dff])🪣️ = 0001 0111 #🦢️(fresh swap)
#####################
#24🪡️19 = a in 
0001 1000 #0001 0011 (24)
0000 0011
0000 0011
#0000 0101
0001 0010
#25🪡️20 = b in 
0001 1001 #0001 0100 
0000 0011
0000 0011 
#0000 0110
0000 0101
#26🪡️21 = sel in 
0001 1010  #0001 0101 
0000 0011
0000 0011 
#0000 0111
0000 0110
#27🪡️22 = out
#0001 1011 #0001 0110 🦢️(fin in)
#0000 0011
#0000 0011 , #loop back up here
#???? #????
#    PARTS:
#####################

###################
#CLI STARTERS OUT

#0000 0011 0000 00110000 0011,0001 1000
0000 0011 0000 00110000 0011,0001 1001
0000 0011 0000 00110000 0011,	0001 1010
##################


#    Not(in=sel, out=Notsel);
#27🪡️23 = Notsel
0001 1011 #0001 0111  #🦢️
0000 1000
0000 0011 ,
0001 1010  #0001 0101 #🦢️finot



 #################
   # And(a=a, b=Notsel, out=NotselAnda);
 #28(🪡️24 = And1
0001 1100 #0001 1000,    #🦢️ (tricky cuz same #set!)
 0000 1000, #

 0001 1011 #0001 0111  # < b 💱️(reswaps)
 0001 1000 #0001 0011	# < a 💱️
 
##########&10
 0001 1100 #0001 1000, #🦢️
 0000 1000
 0000 0010 #!
 0001 1100 #0001 1000, #🦢️
 
 #####&!!
  0001 1100 #0001 1000, #🦢️
 0000 1000
 0000 0011 #&
0001 1100 #0001 1000, #🦢️
 #######]}&=ON
 
 #a=a, b=Notsel[cli]ON
 #0000 0011 0000 00110000 0011,0001 1100  #]on2]3! #🦢️
 ###########################################
 
 #&++
#|   a   |   b   |  out  |
#|   0   |   0   |   0   |
#|   0   |   1   |   0   |  # = high z out. 
#|   1   |   0   |   0   |  # = GOOD 
#|   1   |   1   |   1   |

###########################################🧶️unvin🧶️
  #  And(a=b, b=sel, out=selAndb);
  
  ###################
#CLI STARTERS OUT

#0000 0011 0000 00110000 0011,0001 1001 
#0000 0011 0000 00110000 0011,0001 1010 
##################
   #################
 #29🪡️25 = And2
0001 1101,  #0001 1001 #🦢️29
 0000 1000, #🪢️

 0001 1010   # < b
 0001 1001 	# < a
 
##########&z
0001 1101,  #0001 1001 #🦢️
 0000 1000
 0000 0010 #!
 0001 1101, #0001 1001   #🦢️
 
 #####&!
 0001 1101, #0001 1001
 0000 1000
 0000 0011 #&
0001 1101, #0001 1001
 #######]}&=OFF
  #And(a=b, b=sel[cli]OFF
 #0000 0011 0000 00110000 0011,0001 1101 #]on2],3?]ON
###################################################################
   # Or(a=NotselAnda, b=selAndb, out=out);
  
 # its 2nots and nand = 5 
 ###################################################################
 #30🪡️26 = or.#🦢️
 
 #CLI
# 0000 0011 0000 00110000 0011,0001 1100 #nns
#0000 0011 0000 00110000 0011,0001 1101 #snb
############################CLI
 #!a
 0001 1100,  0000 1000 0000 0011 , 0001 1100
 #!b
0001 1101  0000 1000 0000 0011 , 0001 1101 
 
#CLI!
# 0000 0011 0000 00110000 0011, 0001 1100
#0000 0011 0000 00110000 0011,0001 1101 
 #################@
0001 1101 #0001 1010  #30🪡️26
 0000 1000, 

 0001 1100#0001 1001  # < b #🦢️
0001 1101  #0001 1000	# < a #🦢️
 
##########NOT(no not here for "OR"tx...weird...
 
0001 1101#0001 1010 #🦢️
0000 1000, 
 0000 0010 #
0001 1101#0001 1010 #🦢️
 ################@
#CLI out
#0000 0011,0000 0011,0000 0011 ,0001 1101
#

#mux
#|   a   |   b   |  sel  |  out  |
#|   0   |   0   |   0   |   0   |
#|   0   |   0   |   1   |   0   |
#|   0   |   1   |   0   |   0   |
#|   0   |   1   |   1   |   1   | #off?no(clk is last
#|   1   |   0   |   0   |   1   | 
#|   1   |   0   |   1   |   0   |
#|   1   |   1   |   0   |   1   |
#|   1   |   1   |   1   |   1   |

 #}MUX]NU]ON
 
 #o|++
#|   a   |   b   |  out  |
#|   0   |   0   |   0   |
#|   0   |   1   |   1   |  # = high z out. 
#|   1   |   0   |   1   |  # = GOOD 
#|   1   |   1   |   1   |

#D-in 

0001 0100 #0011 0000
0000 0011
0000 0011
0001 1101

#NOT 
0001 0101 #0011 0001
0000 1000,
0000 0011 #
0001 0100



#top nunq(pre latch)A 
0001 0110 #0011 0010
0000 1001

0001 0100 #0011 0000
0000 0111

######################
#bottom nunq(pre latch)B
0001 0111 #0011 0011
0000 1001

0001 0101 #0011 0001
0000 0111

#####################


######################
#LATCH START 
##########################################################
#a___
0001 0000,
 0000 0011
 0000 0011 #
0001 0110
#b___

0001 0001,
 0000 0011,
 0000 0011 #
0001 0111  #< ur"a'var has to go in "B" if u want it "HI-z'd out"

#################
0001 0010,
 0000 1001, #🪢️

 0001 0011  # < b
 0001 0000	# < a
 

######################


0001 0011,
 0000 1001, #🪢️
 0001 0010  # < b
 0001 0001	# < a
 
 
######################

#pre Qstates
0000 00110000 00110000 0011 0001 0010
#0000 00110000 00110000 0011 0001 0011
#BIT1#1️⃣️0000
