#ğŸ“œï¸
#save this 2 'oldscroll" with unoman + binary.txt?<works is smoller tbh
#ğŸ£ï¸may wanna do some testing b4 u do "ALL THAT " ;) 
#ğŸ“œï¸
#ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸

#having problems its not even doing 16 / 32 
#it seems 2 stop counting @ 8bit i may have to rewrite bin in
#and get a handle on the situation :/ 
#makes me wonder if it would be better 2 do it in c/js
#cuz thers probably peices u could peice 2 gether. w/e 
#just finish it in asm ofc. im sure youll get 2 the bottom of it
#cuz addrs obviously can handle the full 64. 
#maybe just do it full 64 or we works for u its very weird tho
#â•ï¸
#youll probably be able 2 debug / fix 64 easier once 32 is done cuz +infrastruct-kruft
#https://github.com/copy/v86/blob/master/src/memory.js (see how this handles 64+mem. wtf?(in pages of 32...)
#U shouldn' need that tho cuz we HAVE count up 2 64bits reg space....

#could end up adding "line #" (as auto-comments (2 right, as well as "HEX of BIn")
#just for readablility (reading OTHER PPLS HEX (in c/elf/pe etc) 

#â•ï¸
#u can also make this a "VHDL 2 HALO" compiler later, u just have to interpet that a 
#"NEW HEADER WANTS TO CHANGE COMMANDS"(its an ez add on , dont sweat it )<3
#â•ï¸
#==================
#it should calc first number - compare 2 second if lower add if higher subtract just add first
#then it should copy  "7x(0111)" adding +1 address each time (ignoring the "11's")

#if "count is less than "2" grab base/mult...

#it could even be 4 "as in "bits / "current base" if u dont trust w/e base is "current"

#after all it could be wrong (it could be skipped or something and i dont think u wanna 
#fool with that when THIS Is so easy AND 2 STD...

#===================

#ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸ğŸ¡ï¸
#ğŸŒï¸19-20 (no sooner) (go 2 bed well past 4 
#ğŸ“ï¸
#ğŸš§ï¸
#ğŸ“…ï¸does log use "load buffer?"
#ğŸ”ï¸
#mod spex latest? 
#do all modem "DYNAMIXALLY" DEFINATELY CUZ 3+ networking WILL BE DONE SOON (even if its "slower")
#tho i dont think it will be , this stuff runs "OS's" but maybe.
#DO MODEM strinc FEED (NOT 1pg BIT BUT SINCE ITS DYNAMIC LENGTH GETS LONGER , keep reading inc.

#u may not actually have to "LOAD FILE 2 buffer ? " how was cli doing it? (probably tho...)
#ğŸ”ï¸

#â˜ï¸ MODS = go 2 > 0-3 (instead of 15s , so i can store "FX" IN FX related wires...) 

#â˜ï¸ add modem io from 2 files . ğŸ“¥ï¸ğŸ“¤ï¸
#++++++++++
# < ~[]           
#é›¶ä¸€äºŒä¸‰
#linq(0),i(1),h(2),sn(3) 
#~?
#0.é›¶ (rei)zero ,1.ä¸€. (ichi) one , äºŒ. (ni). two , ä¸‰. (san). three Â· 
#0 â€“ ì˜ (yeong),1 â€“ ì¼ (il),2 â€“ ì´ (i),3 â€“ ì‚¼ (sam)

#change legend 2 have "TX as 0100" for "LI"  <EZ just do it
#swap code words in txt
#ship that , no more mods ever probably...
#may change num buttons 2 ^'s later...
#ğŸ¦¢ï¸
#*swap with | = il asap pls. 
								#then nand (as in 0101(2) txs)
								#then 110 = 0switch 111 =1 switch
								#then modem in = 1000 
								#then modem out = 1001
								#(then clock = 1010
								#(do this b4 modems pls)
								#(or u can do modems at
								#(1110 1111 for now w/e )
								#y rock the boat? (time isn't 8)
								#ğŸ¦¢ï¸
#ğŸ—»ï¸
#ğŸ’¾ï¸
#may add save / load state later 
#u can use special mark 2 diff ram from clock and start clock load etc
#can trigger from cli of "HALO" (6-7)
#can probably also easily designate filename by typing it 
#but who wants 2 do that...(no autocomplete ofc)
#ğŸ’¾ï¸
#may also do "STOp clock somehow , 2 get "psudo kbd input" till we have IO.
#it will just throw an "interupt" 2 our clock 
#maybe triggered with a "_fx__" dunno. 
#ğŸ—»ï¸
#ğŸ‘·ğŸ»â€â™€ï¸ï¸
#also... y the hll are u doing "MODEM" right NOW? (we just finished mux
#(other than maybe their bored of making wires? 
#its good 2 have other things 2 "CODE ON" in a sp sort of way
#u could stop now tho , or even work on "save_load" state
#ur also probably gonna make a "stop4kbd" "interupt" 
#till u actually get "IO" ...

#ğŸ“Ÿï¸
#and finally u may even designate file / files from cli...
#would put save/load b4 modem io becaseu thats actually priority ... 
#ğŸ“Ÿï¸
#ğŸ‘·ğŸ»â€â™€ï¸ï¸

#âš ï¸
#just make sure whenever u stop(For the day!) the old code still works ! 
#âš ï¸
#ğŸš§ï¸
#ğŸ“ï¸




#ğŸ§¿ï¸the bin laying dormant helped wont get lost
#ğŸ§¿ï¸it shouldn't be THAT hard do it later if stress finish school
#ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸
#when u are able to optionally parse 16mux8 and do io (2riscv/arm and x86self). this code will be BEEST
#also its transferable 2 other archs, forever. 
#take ur time , u will get there quicker than u think
#comign from tokngn, i can vouce for this , took much longer
#2 learn asm than 2 code the engine
#ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸
#ğŸ§¼ï¸2do
#ğŸ“†ï¸may9]0.take file in from cli/bash only>go fast
#>[]


.section .data
#ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸
prompt_str1:
    .ascii ":1=!1,:2=!2,:3=z1:,4=z2,5=Loop,6=SV,7=LD 8=14 9=24 " #save load state 
str1_end:
    .set STR1_SIZE, str1_end-prompt_str1
prompt_str2:
    .ascii "Enter second number: "
str2_end:
    .set STR2_SIZE, str2_end-prompt_str2
    
    clock_out_8bit:
.ascii "::::::::"
#ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸ğŸ§µï¸
#######CONSTANTS########
#system call numbers
    .equ SYS_OPEN, 2
    .equ SYS_WRITE, 1
    .equ SYS_READ, 0
    .equ SYS_CLOSE, 3
    .equ SYS_EXIT, 60
    
     .equ ST_FD_OUT, 56
     
       .equ O_RDONLY, 0
    .equ O_CREAT_WRONLY_TRUNC, 03101
#standard file descriptors
    .equ STDIN, 0
    .equ STDOUT, 1
    .equ STDERR, 2
        .equ END_OF_FILE, 0  #This is the return value
                         #of read which means weâ€™ve
                         #hit the end of the file
    .equ NUMBER_ARGUMENTS, 2
    #______________________
     #âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸
ioperm_message:
    .ascii  "ioperm() failed, run as root or sudo\n"
    #âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸#âŒ¨ï¸
    
 
ascii_16_test_0:
.ascii "xxxxXXXXyyyyYYYY"
    
ascii_8_prog_0:
.ascii "12345678"

      #ğŸ§¹ï¸TEMTğŸ§¹ï¸
     ascii_8_test_0:        #ascii_8_prog_0:(mt)
     .ascii "xxxxxxxx"
     ascii_8_test_0_end:
.equ ascii_8_test_0_len, ascii_8_test_0_end - ascii_8_test_0
    #ğŸ§¹ï¸TEMTğŸ§¹ï¸

#ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸
#*******"REGISTARS"*******
#__________PROG_16.4x4
#ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸
#theres no header, im not gonna delete it right now and break prog. but will swap 4 out l8r
ascii_4_head:   #header
.ascii "0000"


ascii_4_a:
.ascii "0000"

ascii_4_b:
.ascii "0000"

ascii_4_i:
.ascii "0000"

ascii_4_outcode:
.ascii "0000"



ascii_4_test_0:
.ascii "same"     #"tes0"

ascii_4_test_1:
.ascii "same"   #"tes1"
#__________PROG_16.4x4
####
#--------------=====output tail or full as log 2 prove u have
ouput_4_0:
.ascii "0000"

#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸
ascii_8_a:
.ascii "........"

ascii_8_b:
.ascii "........"

ascii_8_c:
.ascii "........"

ascii_8_d:
.ascii "........"

#ğŸ§¼ï¸
ascii_0x_32_a:
.ascii "................................"

ascii_0x_32_b:
.ascii "................................"

ascii_0x_32_c:
.ascii "................................"

ascii_0x_32_d:
.ascii "................................"

ascii_0x_64_a:
.ascii "................................................................"

ascii_0x_64_b:
.ascii "................................................................"

ascii_0x_64_c:
.ascii "................................................................"

ascii_0x_64_d:
.ascii "................................................................"


ascii_0b_32_a:
.ascii "00000000000000000000000000000000"

ascii_0b_32_b:
.ascii "00000000000000000000000000000000"

ascii_0b_32_c:
.ascii "00000000000000000000000000000000"

ascii_0b_32_d:
.ascii "00000000000000000000000000000000"
#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸#ğŸ§¼ï¸
#ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸ğŸª£ï¸
#âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸
#ğŸ¤ºï¸
token_prog_0:
.ascii "0000"
#ğŸ¤ºï¸
token_test_prog_0:
.ascii "01!A"  "alpha bet for output registers...?4 now?"
		#using o for now cuz only 1 out w/e tho
		#not the biggest issue
#ğŸ¤ºï¸
token_array_multi_chip_0:
.ascii "10&aa1&bab!c"   #should we use "o" or "abc" not sure
#ğŸ¤ºï¸

#######this is for the actuall binary in.
token_array_16_2_4_0:
.ascii "0000"
#ğŸ¤ºï¸


#ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸
ram_4_0:
.ascii "0000" 
###################################
ram_16_0:
.ascii "0000\0000\0000\0000" 
# "." ? = space 4 last period? ğŸ‘ï¸<try count 1rst
ram_32_0:
.ascii "...............................x"  
# "." ? ğŸ‘ï¸
ram_64_0:
.ascii "................................................................"
#.ascii #"0000000000000000000000000000000000000000000000000000000000000000"
#.ascii #"________________________________________________________________"

ram_128_0:
.ascii "................................................................................................................................"

ram_128_v_0:
.ascii "................................................................................................................................"

ram_256_0:
.ascii "................................................................................................................................................................................................................................................................"


ram_256_v_0:
.ascii "................................................................................................................................................................................................................................................................"

ram_256_cli_0:
.ascii "................................................................................................................................................................................................................................................................"



ram_64_history_0:
.ascii "................................................................"



ram_64_v_0:
.ascii "................................................................"


ram_64_v_history_0:
.ascii "................................................................"

ram_64_t_0:
.ascii "................................................................"


#ğŸ‘¹ï¸ just assume 4 bits. prog end? worry bout it when u get there

#ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸
#âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸
#â•ï¸
#ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸PRE-EQ (these should just be ascii compares...
	.equ reg_a  , 1000 
	.equ reg_b  , 1000
  	.equ inst , 10
  	.equ out , 0
  	.equ car , 0
  	#ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸
  	#ğŸ›ï¸EQ
   .equ lo , 0b0000  # 0b0000 ? YES the only way m8
   .equ hi , 0b0001 
   #!!!!!!!!!!!!!!!!!!
   .equ not , 0b0100  #0b0100 
   
   	      #32     
   .equ not, 0b100001 #=33'!' #trying trix 4 "2nots"
   			#i seen in some dissasemblys
			#hope it uses first for (calls 2 ;)
			
	#.equ not # = 241 w/0 - 48 ... why?
	#NO the symbol is #1 but i guess thats alt
	#however 8bits only goes up 2 "127" so... naw...
			
   #!!!!!!!!!!!!!!!!!!!!!!
   #@@@@@@@@@@@@@@@@@@@@@@
   .equ nand , 0b0110 	  		
   .equ nand , 0b1000000 #=64'@' 
   #@@@@@@@@@@@@@@@@@@@@@@
   #---------------
   	
   .equ jno , 0b0010  #jo(for4bit) #cmp? sub? or w/e we need
   
   .equ jno , 0b101000 #= 40'('
   
   .equ jne , 0b0011  #jb? add ? (SHIFT LEFT ? RIGHT?) (ele) 
 .equ jne , 0b101001
   ########------3limit end
   .equ shl , 0b1000
   .equ shr , 0b1001
   #ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸
   #ğŸ§±ï¸
 .equ out_kode , 0b1010  #=10 (og out kode ) 
.equ out_kode ,   0b1001111  #=79 'O'
.equ karry_kode , 0b1011
.equ karry_kode , 0b1001011  #=75 'K'
#ğŸ§±ï¸
#should !& binary just be value of "ascii? (no not gonna fit) 15.bits 
#unless u do 127 but i rather have relevant 4 2 8bit conversion for HDL tbh fam 8bit is ez.(alredy don) 
# https://commons.wikimedia.org/wiki/File:ASCII-Table.svg

#ie before u push the "token" ask if its "same number as (decided token revalue)(
#ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸ğŸ”Œï¸(grab from macrospec when ur ready)


  #\\\\\\\\\\\\\\\\\\\\\\\\\\\  
newline_out:
.ascii "\n"

ascii_sing:
.ascii "."

sing_test:
.ascii "ì—˜"

err_msg_0:
.ascii "'!ë´‡,å¯©æŸ¥,||<<>>'\n"  #Please Review Process (||<<>>)  
     err_msg_0_end:
.equ err_msg_0_len, err_msg_0_end - err_msg_0

#\\\\\\\\\\\\\\\\\\\\\\\\\\\



#.section .text


#-----------------
#segfaults if there is more code than bss#just needed 2 widen .bss. 
#.bss = bytes. (i dont think theres a limit but probably dont wanna abuse
  #-------------------------
    .section .bss
    .equ BUFFER_SIZE, 1600000*10 #130023424 #1024*1024*1024 #1,600,000 
    .lcomm BUFFER_DATA, BUFFER_SIZE  
    
      
    .equ test_SIZE, 500
    .lcomm   test_DATA, test_SIZE
    
     .equ DIFF_BUFF_SIZE, 500
    .lcomm   DIFF_BUFF_DATA, DIFF_BUFF_SIZE
    
    #using * 2 widen buffer has worked fine for now THANK GOD
#i've even seen it able 2 go wider? but it does get weird at some point
#but we will rock with it till it REALLY BLOWS...
.lcomm      input1  2
.lcomm      input2  2
.lcomm      ans     1

    #--------------------------
.section .text #not having this caused SEGFAULT ! watch 4 ğŸ”­ï¸
#â•ï¸
# file name 
.equ ST_LOG_OUT_0 , -16
.equ ST_LOG_OUT_1, 72
.equ ST_LOG_OUT_2, 80 #log out 8 bit 1  2 other first
#â•ï¸

#STACK POSITIONS
    .equ ST_SIZE_RESERVE, 16 #i dont see a use 4 this
    			#but will keep eyes peeled
    			#as i go thru 1 by 1...
    .equ ST_FD_IN, 48 # i made these pos, keep an eye on that.
    .equ ST_FD_OUT, 56
    #u must add 16 to all these u simply must
    .equ ST_ARGC, 16#0      #Number of arguments
    .equ ST_ARGV_0, 24 #8   #Name of program
    .equ ST_ARGV_1, 32 #16   #Input file name
    .equ ST_ARGV_2, 40   #Output file name
    
    #â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸
    #â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸
    
        #â•ï¸
filename_in:
    .ascii "?64]ğŸï¸.hlo\0"
    filename_out:
    .ascii "out.yr\0"
    logname_out:
    .ascii "logout]ğŸ–¨ï¸.txt\0"
    
     modem_filename_in:
     .ascii "modem_in]ğŸ“¥ï¸.hlo\0"
      modem_filename_out:
     .ascii "modem_out]ğŸ“¤ï¸.hlo\0"
     
     
      save_state_filename_in:
     .ascii "state_load_in]ğŸ’¾ï¸.hlo\0"
      load_state_filename_in:
     .ascii "state_save_out]ğŸ’¾ï¸.hlo\0"
#â•ï¸

#ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸
#âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸
#âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸
#âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸âœ¡ï¸
#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸
.globl _start
_start:
mov  %rsp, %rbp
#########################
#call test_hlsbyte_0
#call exit
#############
call sys_in

call sys_out #designate outfile

call log_open

#ğŸ–ï¸
call load_buff #puts buff in BUFF_DATA nothign fancy 

#call modem_open


#call save_state_open
#call load_state_open
#ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸#ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸#ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸

		
call buffer_comment_0
call buffer_stripper_0
#ğŸ“ï¸ğŸ“ï¸ğŸ“ï¸ğŸ“ï¸ğŸ“ï¸ğŸ“ï¸ğŸ“ï¸
#call buffer_to_ram_64   #64-2-64 for now? bigger or smaller should be ez

call print_buff        #ğŸ§¨ï¸ < when i move this it clobbers wire ? 
call ascii_newline
call a2b_1
#call kbd2ascii_io_0   #ğŸ§¿ï¸


call log_out #will do manually 
#ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸



#call print_err_0
call ascii_newline

#ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸


#ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸#ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸#ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸ğŸ”¯ï¸

################


call ascii_newline

call exit
#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸#ğŸ²ï¸
 
#ğŸğŸğŸğŸğŸ
exit: #Table C-1. Important Linux System Calls 

#%eax]	Name]	%ebx]	%ecx]	%edx]	Notes]
#1]	exit]	ret val	_	_	exits
#3]	read]	file]	buf *rt	buf siz	reads into buffer
#4]	rite]	file]	buf *rt	buf siz	write buffer into file
#5]	open]	file]	optn	perm	opens file returns file/err
#6]	close	file]			closes file descriptor 


mov $1, %rax

#mov $201, %rbx# this is the status number we will

int $0x80# this wakes up the ker
#ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ

#ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸

#ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸ğŸš§ï¸
.equ ST_BUFFER_LEN_0, 16
.equ ST_BUFFER_0, 24
#ğŸ—“ï¸





#ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸

 #âŒï¸< MOVE THESE IN HALO WHEN U RE-NOTICE ! (not now , test xtensively#âŒï¸<
  .equ clock_edge , 80  #1,or,0s
  .equ clock_count , 88 #:+-
  
  .equ switch_state , 96  #1,or,0s
  .equ switch_state_2 , 104  #1,or,0s
  
  #â˜ï¸
  .equ modem_in_stack_pos , 112  #replace with "3' everytime so it defaults (fx loops m8)
  .equ modem_out_stack_pos , 120  #1,or,0s
  
   .equ modem_in_single , 128  #replace with "3' everytime so it defaults (fx loops m8)
  .equ modem_out_single , 136
  
    .equ modem_in_count , 144  #replace with "3' everytime so it defaults (fx loops m8)
  .equ modem_out_count , 152 #1,or,0s
  
  .equ modem_in_offon , 160  #0=off 1=on dont do this if u dont need, just skip fx[trigger] <3 
  .equ modem_out_offon , 168 #0=off 1=on dont do this if u dont need, just skip fx[trigger] <3 
  #â˜ï¸
  
  #ğŸ’¾ï¸
      .equ save_state_pos , 144  #replace with "3' everytime so it defaults (fx loops m8)
  .equ load_state_pos , 152 #1,or,0s
   #ğŸ’¾ï¸
  
 
 # movq  0(%rsp), %rax #value 2 print (save it)
# movq  8(%rsp) , %rdx 
# movq  16(%rsp) , %rsi 
 # movq  24(%rsp) , %rdi 
 #ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸
 .equ rax_pos , 160 
 .equ rbx_pos , 168 
 .equ rcx_pos , 176 
 .equ rdx_pos , 184
 
 .equ rsi_pos , 192 
 .equ rdi_pos , 200 
 
 .equ r8_pos , 208 
 .equ r9_pos , 216 
 .equ r10_pos , 224 
 .equ r11_pos , 232 
 
 .equ r12_pos , 240
 .equ r13_pos , 248 
 .equ r14_pos , 256 
 .equ r15_pos , 264 
 #ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸
#â˜¸ï¸
  .equ command_a , 272 #
   .equ command_b , 280 #
   .equ command_c , 288 #
   .equ command_d , 296 #
   
   .equ command_result , 304 #
   
   .equ mult_ascii_counter , 312 #
   
   .equ mult_macro_countdown , 320 #
   
   .equ command_posneg , 328 #
   
   .equ command_hx , 336 #
   #ğŸ‘©ğŸ»â€ğŸ’»ï¸
   
  #  .equ a_sum , 40
 #.equ b_sum , 48

 #.equ c_sum , 72 # does this order madder?
# .equ d_sum , 64
 
 # .equ e_sum , 56  #this breaks everything for some reason...(doesn't register?)
 #(its because u ALREADY USED IT (u already used a few others 2 , get rid eof !
  #âŒï¸< MOVE THESE IN HALO WHEN U RE-NOTICE ! (not now , test xtensively#âŒï¸<
  #ğŸ˜‡ï¸(obv its working now but yea) (we dont use rsp-stack either etc) 
#â˜¸ï¸ 
 
 
 
 
 ####################
   .equ test_pos_0_0 , 16
 .equ test_inc_1_1 , 24
 .equ test_sum_2_2 , 32
 #ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸ğŸï¸
  .equ ascii_ram_limit_low , 16
  .equ ascii_ram_limit_hi , 126
#########################################
#ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸


#ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸#ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸#ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸
.globl a2b_1   #GODL = TOKENIZATION âš”ï¸âš”ï¸âš”ï¸âš”ï¸
		#we will tokenize inst for now , then do full prog
		#âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸âš”ï¸
a2b_1:
 pushq %rbp 
    movq  %rsp, %rbp
#_________________________
  start_test_a2b_1:  
 
 #ğŸ›¸ï¸(print wont work when ur using stack etc if u dont do this) 
 sub $16, %rsp
 #ğŸ›¸ï¸
#ğŸ”®ï¸

#ğŸ”®ï¸push $11
#ğŸ”®ï¸push $22
#ğŸ”®ï¸push $33
#ğŸ”®ï¸push $44
#ğŸ”®ï¸pop -8(%rsp)
#ğŸ”®ï¸pop -8(%rsp)

#ğŸ”®ï¸

#mov (%rsp) , %rbx
#call exit
#ğŸ”®ï¸
#push $3
#push $4
 #ğŸ‘©ğŸ¼â€ğŸš€ï¸
 #ğŸ§šğŸ»â€â™€ï¸ï¸SO DOES THIS (it was in "4x" not 8 honestly dunno y 8 ever worked... 
 #jmp print_bin_0
#push $8
#push $8
#push $8
#push $8
#sub $16, %rsp #does add work?  #subbing from %rsp is EZ AF = PERFECT
 #ğŸ§šğŸ»â€â™€ï¸ï¸

#jmp print_bin_0
 ################
 movq $0 ,clock_edge(%rbp) #tested=on
 movq $0 ,clock_count(%rbp) #tested=on
 ###########
  movq $ram_256_v_0, %r12 #
  
  movq $48 , switch_state(%rbp)  
   movq $48 , switch_state_2(%rbp)  
   
   movq $'3' , modem_in_single(%rbp) #is reading out as "c'...
   movq $0 , modem_in_count(%rbp)
  #ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸
   re_run_entire_with_new_clock_0:
 #ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸
 
 

  mov $BUFFER_DATA, %r8  #âœ…ï¸do not change this! #DIFF_BUFF_DATA

 mov $0,%r10   #âŒï¸ counts up till abcd_ (then clear till next loop
 
# xor %r11 , %r11
 # movq $0 , %r11 # ram-stack count
 #movq $ram_64_v_0, %r12 #header goes first , ez
 #movq $ram_128_v_0, %r12 #
 
  #ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸
   	# movq $ram_64_0, %r13
   	movq $ram_256_cli_0, %r13
  #ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸ğŸ“Ÿï¸
 mov $0,%r14  #âœ…ï¸ do not change this is counting entire buffer
 #movq $ram_32_0, %r15#âœ…ï¸ #is our "a2b STACK < DONT
 movq $ram_64_0, %r15
 #â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸ğŸ’ï¸

 
# mov clock_count(%rbp) , %rbx
 #call exit
 #ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸ğŸ•°ï¸
 
  
  #.equ clock_edge , 80  #1,or,0s
  #.equ clock_count , 88 #:+-
  
  #ğŸ¦•ï¸ 
    mov  $0, %r14  #counting $BUFFER_DATA , loop,place
  #mov  $7, %rdi  #(counting 8 bit chunks)
  #mov  $31 , %rdi  #(counting 64 bit chunks)
  mov  $63 , %rdi 
  #+++++++++++++++

  #ğŸ¦•ï¸
    ######################################
     mov $0 , %rdx
#ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸ğŸ›‘ï¸

   start_reverse_ascii_in_only_1: 
   xor %rax , %rax 
 
 		 mov  $0, %rax 
   
   mov (%r8,%r14,1) ,%al 
 #  mov %al , (%r15,%rdi,1) 
    mov %al , (%r15,%rdx,1)  #ğŸï¸bin is LSB 32 wise now (was MSB)
    
#u should beable 2 use the dec2bin formula but with add <!> sub
######################################â˜¸ï¸ğŸ¤¯ï¸(its not binary yet
    cmp  $'0', %al #0 #low
   # jl   end_a2b_1   # push_program_tokens_2 #next_byte
   jl end_store_start_mult #ğŸ’ªï¸
    cmp  $'5' , %al #127 #his+
   # jg   end_a2b_1   #  push_program_tokens_2 
  jg end_store_start_mult #ğŸ’ªï¸
   
   #ğŸ‘¾ï¸ > premptively incing since # is already stored...
   #######################################
  	 dec %rdi #
    inc %r14 #is being used as buffer count  
    inc %rdx #is used 2 iterate 32
cmp $-1 , %rdi
   jne start_reverse_ascii_in_only_1
   ########################
   #ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸#red dragon
 	#mov $31 , %rdi   #reusing %rdi after %r15 (ascii) is full
 	 mov  $63 , %rdi 
 	mov  $0, %rcx
 	
 	
 	#ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸#
 	#can we just see %r15 ? 
 	  #ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸
 	 #â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸
      #â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸
    
    #â™‘ï¸#â™‘ï¸#
 #ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸
 	######################
 		 #â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸â¿ï¸
 		 xor %rax , %rax 
 		 mov  $0, %rax 
 		mov %rax , test_sum_2_2(%rbp)
   #movq $0, test_sum_2_2(%rbp)

    #ğŸ‘¾ï¸ 
    
    
 	######################
 	 test_loop_a2b_1: #strip and load loop
#
#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸
xor %rax , %rax 
#if i didn't do this ALL HELL BROKE
#u should be fine for now,,, but just be sure 2 "clear out regs"
#u know? 
#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸
mov  (%r15,%rdi,1) , %al 
sub $48 , %al

shl  %cl , %rax 


#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸

add   %rax  , test_sum_2_2(%rbp) 

#ğŸ“‹ï¸
   dec %rdi
   inc %cl  

# cmp $8, %rdi
#cmp $32, %rdi

cmp $-1 , %rdi
 jne test_loop_a2b_1
 
  #ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸
  
  movq    test_sum_2_2(%rbp) , %rax 
#jmp dec_2_bin_0
 #ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸ğŸ‘¾ï¸ğŸï¸
 #######################################

 
  mov  $63 , %rdi 
 mov $0 , %rdx	  #this was literally the problem!â—ï¸
 	######################
 	 #######################################
 	 #ğŸ‹ğŸ»â€â™€ï¸ï¸ still using 4xcommands
######################
#this "a2d,etc"  is a bit confusing in retrospect but its pretty containerized 
#it was "in reverse so this is swapping it back

#cmp $4 , %r10
#jge push_rax_post_4x

cmpw $49 , switch_state(%rbp)
je push_rax_post_4x


 	 store_result_1: 

 store_result_a:
 cmp $0 , %r10 
 jne store_result_b
 	mov %rax , command_d(%rbp)
 	#mov %rax, %rbx #âŒï¸
 	#call exit	#âŒï¸#âŒï¸ = 51 / 3 
 	
 	
 	
 	
 	
 	jmp end_store_result_1
 store_result_b:
 
	 cmp $1 , %r10 
 	 jne store_result_c
 	mov %rax , command_c(%rbp)
 	#mov %rax, %rbx #âŒï¸
 	#mov %r10, %rbx #âŒï¸
 	#call exit	#âŒï¸
 	
 	
 	
 	jmp end_store_result_1
  store_result_c:	
 	 cmp $2 , %r10 
 	 jne store_result_d
 	mov %rax , command_b(%rbp) #âŒï¸
 	#mov %rax, %rbx #âŒï¸
 	#mov %r10, %rbx #âŒï¸
 	#call exit	#âŒï¸
 	
 	
 jmp end_store_result_1
 
 
  store_result_d:	
 	 cmp $3 , %r10 
 	 jne end_store_result_1
 	mov %rax , command_a(%rbp)

 	#mov %rax, %rbx #âŒï¸
 	#mov %r10, %rbx #âŒï¸
 	#call exit	#âŒï¸
 	
 	
 	#jmp dec_2_bin_0
 

#ğŸ˜±ï¸ 
 #######################################
end_store_result_1:
 	
 	#mov %al ,(%r10,%r10,1)  #goes in backwards! (its ok debug)
 	inc %r10   #loop 4 4 fill, can reuse when 4 is full
 	cmp $4 , %r10 #4 is 2 much
 	jne  start_reverse_ascii_in_only_1
############################################
#ğŸ˜±ï¸ < V i believe the fact that this instantly goes 2 "4" then "0" 
#ğŸ˜±ï¸ means it "works just fine"
#mov $0,  %r10 
mov $0,  %r13
movw $49 , switch_state(%rbp)
#ğŸ˜±ï¸ 
 #ğŸ‹ğŸ»â€â™€ï¸ï¸

######################

#ğŸ§®ï¸ do add/sub HERE ?(mult must be done first , actually  ğŸ§®ï¸
#command?
#sub
#add
#ğŸ§®ï¸ğŸ§®ï¸ğŸ§®ï¸ğŸ§®ï¸ğŸ§®ï¸ğŸ§®ï¸ğŸ§®ï¸ğŸ§®ï¸ğŸ§®ï¸ğŸ§®ï¸
##########################MATH (transplanted)ğŸ«€ï¸################################
########################################################


#ğŸ§®ï¸ do add/sub HERE ?(mult must be done first , actually  ğŸ§®ï¸
#command?
#sub

#mov %rbx, command_result(%rbp)
#command_posneg

#ğŸ§§ï¸
#ğŸ‘–ï¸> change? were gonna save add (and just add negative if necessary)
#ğŸ‘–ï¸ -1+-1=-2 ;) (add at each end. 
##do mult first we wont store a negative (for more space out of gate )

#rbx= desired base : 0001 0000 (shift ?x)(set 2 new post mult)
#rax= current base : 0000 0001 (shift ?x)(set 2 new post mult)

#rbx= desired base : 0001 0000 (shift ?x)(set 2 new post mult)
#rax= current base : 1000 0001 (shift ?x)(set 2 new post mult)
#dont forget 2 use new "RDX" =1111 0010
#= cmp_add 

xor %rdx , %rdx 
xor %rax , %rax 
xor %rbx , %rbx 

mov command_a(%rbp), %rax
mov command_b(%rbp), %rbx


movq $0 ,command_result(%rbp)

cmp_only_mult:
cmp %rax , %rbx  #(have 2 be ing regs)
jz no_difference

cmp_add:
cmp %rax , %rbx
jl cmp_sub

sub %rax , %rbx # 16-1 = 15 (add 15 2 "shr $1 , %rdx"
#ğŸ”»ï¸
movq %rbx , command_result(%rbp)
movq $1 ,command_posneg(%rbp)
#add %rbx , %rdx  #]ON

#mov %rdx ,%rbx 
#mov $91 ,%rbx 
#call exit

jmp end_mult_add

#mov $111 , %rbx
#call exit 

cmp_sub:

sub %rbx , %rax

movq %rax , command_result(%rbp)
movq $0 ,command_posneg(%rbp)

#sub %rax , %rdx

#mov %rdx ,%rbx #]ON
#mov %rax ,%rbx 
#call exit

#mov $100 , %rbx
#call exit 
jmp end_mult_add
anomoly_safe:
no_difference: 

end_mult_add:


movq command_result(%rbp) , %rax 

movq %rax , command_hx(%rbp)

#
#ğŸ§§ï¸á“šá˜á—¢ zzz


#ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸
	

#ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸ğŸ€„ï¸
push_rax_post_4x:


#push %rax  #ğŸ’ªï¸
push test_sum_2_2(%rbp) 
 inc %r13
jmp  start_reverse_ascii_in_only_1

#ğŸ’ªï¸
#âœ‚ï¸âœ‚ï¸âœ‚ï¸âœ‚ï¸âœ‚ï¸âœ‚ï¸#ğŸª±ï¸
		loop_if_2_vi_superficial_4_4x:
		
		#inc %r11 
         #ğŸ–ï¸
#jmp  start_reverse_ascii_in_only_1  

#ğŸ’ªï¸
end_store_start_mult: #ğŸ’ªï¸
xor %r11 ,%r11 
#ğŸ’ï¸
reverse_buffer_0: 
mov $DIFF_BUFF_DATA, %r9  ##ğŸ©ºï¸ #DIFF_BUFF_DATA

mov  $0 , %rsi # #ğŸ©ºï¸< buffer push counter. 


#u dont have to make a new loop , u can push into the buffer @dec_2_bin
#also just wait for newline till were gonna print 
#u can do it as usual tbh 
#ğŸ’ï¸

#jmp print_bin_0
#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸
#ğŸ¦¾ï¸
pre_macro_loop_prep: 

xor %rdx , %rdx 
mov %r13 , clock_count(%rbp)
#ğŸ¦¾ï¸
#â­•ï¸
mult_n_d2b_print_macro_loop: 
#add/sub is done ? (no do during mult)

mov clock_count(%rbp), %r13

#cmp %r10, command_c(%rbp) #MULT
#cmp $5 , %r10
#jz end_mult_n_d2b_print_macro_loop
#âºï¸

d2b_n_print_micro_loop:
#ğŸ’‚â€â™€ï¸ï¸
cmp $1 , %r13 
je end_d2b_n_print_micro_loop
#ğŸ’‚â€â™€ï¸ï¸
dec %r13 
#jmp print_bin_0

mov (%rsp) , %rdx #it may back stack ? lets just find out
pop -8(%rsp)


#ğŸ—ï¸ #ğŸ—ï¸ 
dec_2_bin_loop_start: 

 mov  $63 , %rdi 
mov $ascii_0x_64_a , %r12

ascii_sum_out_loop:
xor %rbx , %rbx


shr $1 , %rdx
jnc no_carry_d2b  #jc 

mov $'1' , %rbx # 1 is carry 
jmp end_carry_d2b 
no_carry_d2b : 
mov $'0' , %rbx

end_carry_d2b : 

mov %bl , (%r12,%rdi,1) #literally didn't work with "RBX" lil endian
#ğŸ©ºï¸
mov %bl , (%r9,%r11,1)
#ğŸ©ºï¸
end_placement_0: 

dec  %rdi 
inc  %rsi 
inc %r11 

# mov  %r11 , %rbx
#call exit

cmp $0 , %rdi
jge ascii_sum_out_loop


#mov  %r11 , %rbx
#call exit

mov  $0, %rcx 
  mov  $63 , %rdi 
 
 mov $0 , %rdx
 
 
  mov $0 , %rsi# ] (everything prints, but turning off causes segfault!
 ####################

  ##â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸
   #ğŸ—ï¸ #ğŸ—ï¸ #ğŸ—ï¸ #ğŸ—ï¸ #ğŸ—ï¸ #ğŸ—ï¸ #ğŸ—ï¸ #ğŸ—ï¸ #ğŸ—ï¸   
    #
    
jmp d2b_n_print_micro_loop

#ğŸ¥§ï¸
end_d2b_n_print_micro_loop:

#jmp mult_n_d2b_print_macro_loop
#mov  %r11 , %rbx
#call exit



#âºï¸
end_mult_n_d2b_print_macro_loop:
 mov  $63 , %rbx
  mov %r11 , mult_ascii_counter(%rbp)
  xor %r11 ,%r11 
   mov command_c(%rbp) ,%r11 
   mov command_c(%rbp) ,%r15
   
 #  mov %r11 , %rbx
  # call exit

    #ğŸ’¡ï¸the "BUFFER" isn't gonna dissapear like stack did 
     #ğŸ’¡ï¸so u should beable 2 "MULTIPLY IT AS MUCH AS U WANT" 
       #ğŸ’¡ï¸the only problem is its in "BINARY NOW :/ " 
        #ğŸ’¡ï¸i kinda rather reconvert it or do binary math . u pick 
         #ğŸ’¡ï¸i dont want to deal with stack any more. since its "Dumb" 
          #ğŸ’¡ï¸just convert for each mult (bin math = bad cuz violent distractions)
          
          #ğŸ¥ ï¸convert "1-64bit-chunk" 2 dec
           #ğŸ¥ ï¸add/sub
           #ğŸ¥ ï¸convert back 2 bin "ascii" 
           #â›©ï¸
            #ğŸ¥ ï¸have converted entire buffer and pushed 2 stack 
            #ğŸ¥ ï¸pop printing will have reversed back 2 normal ;) 
            #*otherwise u could have just printed it now ;) ğŸ¤·ï¸ w/e (one will wirx)
            #â›©ï¸
           #ğŸ¥ ï¸print 
           #ğŸ¥ ï¸loop till micro(page) is empty then till mult(cro) is done. 
           
           #ğŸŠï¸
           
    xor %r10 , %r10
           mov $0, %r10 # mult count

#cmp %r10, command_c(%rbp) #MULT
          #ğŸŠï¸<mult loop_back ğŸ“€ï¸
          
          mult_loopback: 
           
    #ğŸ‘¸ğŸ¼ï¸ printess
    start_buffer_2_print_test:
    
   xor %r8 , %r8 
    xor %r12 , %r12 

 mov clock_count(%rbp) , %r13 #â›©ï¸
  #ğŸ’ï¸

mov mult_ascii_counter(%rbp) , %r8 
sub $64,   %r8 

 #ğŸ’ï¸

start_clock_looper:

 mov  $63 , %rdi 

      start_reverse_buffer: 
   xor %rax , %rax 
    xor %rcx , %rcx 

 		mov %rax , test_sum_2_2(%rbp)
 		
 				
 #ğŸ•ï¸
    convert_2_dec_again: 
     #ğŸ•ï¸
     #ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸
     
     #ğŸ’ï¸%r11 - 64 = 1rst 64 bits (as u actually want them printed...) so. 
#ğŸ’ï¸since we have r11 this shoul dbe ez...duh.


    
   mov (%r9,%r8,1) ,%al 
   # mov  %dl , (%r12,%rdi,1) #ğŸ” ï¸dont want ascii yet. 
    #  mov  (%r15,%rdi,1) , %al 
sub $48 , %al

#mov %rax  , %rbx   #ğŸ¥§ï¸
#mov $92 , %rbx 
#  call exit

shl  %cl , %rax 

add   %rax  , test_sum_2_2(%rbp) 

inc %cl  
#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸#ğŸ”¥ï¸
#ğŸ“‹ï¸
   dec %rdi
   inc %r8
   cmp $-1 , %rdi
  jne  convert_2_dec_again
   #ğŸ“‹ï¸
    #ğŸ’ï¸
   sub $64 ,  %r8 
   sub $64 ,  %r8 
   #ğŸ’ï¸
   mov test_sum_2_2(%rbp) , %rbx #] ON 
   push %rbx
     # mov %rax  , %rbx   #ğŸ¥§ï¸
#mov $92 , %rbx 

     
    #â›ªï¸
    #
    clean_relevant_registers_0:
   
    mov $ascii_0x_64_a , %r12
    
    pull_from_stack_finally: 
       mov (%rsp) , %rdx
  # pop -8(%rsp)
 #(dont need 2 pop!)should probably pop for smaller inc prog...
  
    #ğŸ¤¦â€â™‚ï¸ï¸
 cmp $15,  %rdx
 jle skip_hx
 #ğŸ¤¦â€â™‚ï¸ï¸
  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸
  #
  preadd_invisible:
xor %rax , %rax 
xor %rbx , %rbx 

movq command_result(%rbp), %rax
movq command_posneg(%rbp), %rbx

#ğŸ”»ï¸
    add_posneg_chunk: 
    
    cmpq $0 , command_result(%rbp)
jz null_situation

pos_add_0:
cmpq $1 , %rbx
jne neg_add_0
add %rax , %rdx
jmp null_situation
neg_add_0: 

sub  %rax , %rdx
null_situation: 

#HXHXHXHXHXHXH
cmpq $0 , command_result(%rbp)
jz skip_hx

   mov command_hx(%rbp), %rax 
    add $1 , %rax  #ğŸ”‘ï¸
    movq %rax , command_hx(%rbp) #ğŸ”‘ï¸

skip_hx: 
#HXHXHXHXHXHXH

#call exit 
#ğŸ”»ï¸
      #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸  #ğŸï¸
    
    end_posneg_chunk:
    
   
   
  # movq %rdx, %rbx
 #  call exit 
    
    #skip this for now and just print pls. (printed ;) its all good
    convert_to_final_binary:
    #ğŸ–¨ï¸[print test RIGHT NOW , before adding (as usual;)]


  #ğŸ›ï¸
   debug_local_0:
   #cmp %r13,  %r13
   cmp $1,  %r13
   jne end_debug_local_0
   
   #mov %r13 , %rbx
   mov %rdx , %rbx
call exit   
   end_debug_local_0:
   # call exit 
    #ğŸ›ï¸
    #ğŸ«€ï¸
    #ğŸ—ï¸ #ğŸ—ï¸ 
dec_2_bin_loop_start_re: 
xor %rdi ,%rdi 
xor %rsi ,%rsi
mov $0 , %rsi 
 mov  $63 , %rdi 

ascii_sum_out_loop_re:
xor %rbx , %rbx

shr $1 , %rdx
jnc no_carry_d2b_re  #jc 

mov $'1' , %rbx # 1 is carry 
jmp end_carry_d2b_re 
no_carry_d2b_re : 
mov $'0' , %rbx

end_carry_d2b_re : 

mov %bl , (%r12,%rdi,1) #literally didn't work with "RBX" lil endian
#ğŸ©ºï¸
#mov %bl , (%r9,%rsi,1)
#ğŸ©ºï¸
end_placement_0_re: 

dec  %rdi 
inc  %rsi 

cmp $0 , %rdi
jge ascii_sum_out_loop_re

mov  $0, %rcx 
  mov  $63 , %rdi 
  mov $0 , %rsi
 mov $0 , %rdx
 ####################

  ##â£ï¸#â£ï¸#â£ï¸# 
   #ğŸ–¨ï¸ğŸ’µï¸ #ğŸ–¨ï¸ğŸ’µï¸ #ğŸ–¨ï¸ğŸ’µï¸ #ğŸ–¨ï¸ğŸ’µï¸

print_bin_0:
  #â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸

      #â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸
     mov  $newline_out , %rsi      #this buffer 
    movq  $1, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
  
   movq  ST_LOG_OUT_0(%rbp), %rdi 
    syscall
    #â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸


#ğŸï¸
mov $ascii_0x_64_a ,  %rsi 
#ğŸï¸   
    movq  $64, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
 
 #ğŸ›¸ï¸
   movq  ST_LOG_OUT_0(%rbp), %rdi 
  
  #ğŸ›¸ï¸when using stack (ther was a "4" in ST_LOG_OUT_0(%rbp))
  #ğŸ›¸ï¸and code displaced it but placed binary "4' in here which let it print
   #ğŸ›¸ï¸(only if that stack pos was "4" crazy but shouldn't happen duh...
  #ğŸ›¸ï¸sol = sub $16 , %rsp ;) ğŸ‘¨ğŸ½â€ğŸš€ï¸
  
    syscall
    #â™‘ï¸#â™‘ï¸#
    #â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸
     mov  $newline_out , %rsi      #this buffer 
    movq  $1, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
  
   movq  ST_LOG_OUT_0(%rbp), %rdi 
    syscall
    #â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸#â™‘ï¸
     
    
    ##â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸
   # mov  $19 , %rbx 
   # call exit 
   
    #ğŸ–¨ï¸ğŸ’µï¸ #ğŸ–¨ï¸ğŸ’µï¸ #ğŸ–¨ï¸ğŸ’µï¸ #ğŸ–¨ï¸ğŸ’µï¸
  
  #â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸#â£ï¸
    #ğŸ«€ï¸
    
    
     # cmp $1,  %r13
      #ğŸ“†ï¸ğŸ“ï¸
 #  ja add_sub_chunk #<doing tommorow (aug19)
   #  call exit
    
    
#ğŸ•°ï¸



dec %r13 
  cmp $1,  %r13
   jne start_clock_looper
  #ğŸ•°ï¸   
    #ğŸ–¨ï¸[]
    
    dec %r15


#ğŸ§®ï¸   
   mov command_hx(%rbp), %rax 
  
    movq %rax , command_result(%rbp) #ğŸ”‘ï¸
    
    #ğŸ¦ˆï¸i BELIEVE this is GOOD2GOD(FOREVER)
    #but if not. u can just (put it in add logic or xMULT it here...
    #tho that doesnt' actually make sense but its ur code <3 
   #ğŸ¦¦ï¸may evern require some OTHER case i haven't anticipated...
   #ğŸ¦¦ï¸but make sure u structured ur logic right b4 u change src <3 
 #ğŸ§®ï¸   
   # mov  %r15 , %rbx 
  # call exit
    cmp $0,  %r15
   jnz start_buffer_2_print_test
 
     #â›ªï¸
    #ğŸ›•ï¸
    convert_back_2_ascii:
      #ğŸ›•ï¸
    mov $92 , %rbx   #ğŸ¥§ï¸
 #mov  %r13 , %rbx 
   call exit



    
crude_mult_test: 


    
    
    
    
    end_buffer_2_print_test:
     #ğŸ‘¸ğŸ¼ï¸
#â­•ï¸
#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸#ğŸ¡ï¸

#mov $92 , %rbx
#mov 24(%rsp) , %rbx

#call exit 
#ğŸ’ªï¸
#ğŸ–¨ï¸
#ğŸ–¨ï¸
 #ğŸ›‘ï¸
    end_a2b_1:
    
    mov  %r11 , %rbx #r11 is perfectly manageble as of now
    mov  %r13 , %rbx 
    call exit
    
 popq  %rbp
    ret 

#ğŸ¥¼ï¸ğŸ¥¼ï¸
    
    
    
    #âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸
    
    
    
    #âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸
    
    
    
    
    #âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸
    
    
    
    
    
    
    
    
    
    
    
    #@âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸
.globl kbd2ascii_io_0 
		#âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸
kbd2ascii_io_0:
 pushq %rbp 
    movq  %rsp, %rbp
#_________________________
 start_kbd2ascii_0:  
 

 ###########
  
  
 movq $ram_64_0, %r8 #header goes first , ez
mov $0 , %r9 # ram-stack count
###############

#i dont think u wanna even look at bios way
#i think u need 2 use either "ps/2" or
#get the port # for kbd <-(scalable)

get_io_perm_0: 
 # ioperm(0x42, 32, 1)
    mov     $173, %rax  # ioperm() == 173 in x86_64
   # mov     $0x42, %rdi # from port 0x42 = 66
   mov     $0x0, %rdi
   # mov     $32, %rsi   # num ports, to port 0x62 = 98...
   mov     $0x0cdb , %rsi 
    mov     $1, %rdx    # enable
    syscall
    cmpl    $0, %eax
    je      start_kbd_0
    
     # ioperm() returned error,
    # write(1, ioperm_message, 13)
    mov     $1, %rax    # write() == system call 1
    mov     $1, %rdi    # stdout
    mov     $ioperm_message, %rsi
    mov     $37, %rdx   # message length
    syscall
    mov     $1, %rdi    # set retcode 1
    call     exit

start_kbd_0: 
clear_0:
  in $0x60, %al

    mov %al, %cl

loop_k_0:

#"DOES" segfault if i dont get perms...)

    /* Store the scancode to al. */
  in $0x60, %al  #segfaults immediately do i need perm?(yes its on now)
#in $0x64, %al
#in $9, %al
#in $0x16, %al

 # mov %al , %bl
  #   call exit  
#cmp %al , %cl
 #  jz loop_k_0

#â£ï¸based on the behavior i believe this is NOT kbd output
#BUT THE INFRASTRUCTURE IS DAMN GOOD...#â£ï¸

mov %al , (%r8,%r9,1)  #on. but going 2 fast...(only gets "ï¿½")
    # mov $49 , (%r8,%r9,1) #on
     
     #mov $91 , %rbx
  #  mov %al , %bl
   # call exit 
     
    inc %r9
  cmp $3, %r9

 
  je end_kbd2ascii_0
    jmp loop_k_0
    
    loop_clk_0:
 mov $0x08, %al  #8=month #segfaults if no perm = <3
 
 #.equ RTCaddress, 0x70
#equ RTCdata, 0x71
    out %al, $0x70
    in $0x71, %al
    
    mov     %rax, %rbx
    call     exit
    
    inc %r9
  cmp $22, %r9

  je end_kbd2ascii_0
    jmp loop_clk_0



end_kbd2ascii_0: 
 popq  %rbp
    ret 

#âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸
#âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸
    
    
    
    
    
    
    
    
    
    
    
    
    
    #âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸#âï¸
 

#ğŸ¥¼ï¸ğŸ¥¼ï¸
#ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸

 
#â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸

#ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸ğŸš¿ï¸



#ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸ğŸ¥¼ï¸
#ğŸ”¢ï¸ğŸ”¢ï¸ğŸ”¢ï¸ğŸ”¢ï¸
#(if u wanted 2 fix it u would just fix the 
#(buffer out from looking "crazy" 
#(dont sweat it tho maybe on bootstrap we can revist it afresh)
#ğŸ”¢ï¸ğŸ”¢ï¸ğŸ”¢ï¸ğŸ”¢ï¸
.globl buffer_stripper_0
buffer_stripper_0:
 pushq %rbp 
    movq  %rsp, %rbp
    
    mov $BUFFER_DATA, %rax
    mov $BUFFER_SIZE, %rbx
    
    
  mov $0, %rdi
    mov $0, %rsi
    cmp $0, %rbx
    je end_buffer_stripper_0
    
 strip_loop:  	# was convert_loop:
    		#will move to external file and do 'nand' 
    		#or do them out of the not gate as tx 
    mov (%rax,%rdi,1), %cl  # lower byte of rcx
    
    
  # need to jump before doing this if byte is not "1 or zero" (its editing "[,]"


cmpb $9, %cl #ascii for 'tab\ '
je next_bit_strip

cmpb $10, %cl #ascii for 'n\ '
je next_bit_strip
cmpb $32, %cl #ascii for ' '
je next_bit_strip
cmpb $44, %cl #ascii for ','
je next_bit_strip
cmpb $91, %cl #ascii for '['
je next_bit_strip
cmpb $93, %cl #ascii for '['
je next_bit_strip



  ###########################################
# think im gonna put comment stripper in new fx. 
#this one getting rediculous , its better this way trust me <3 
 to_buff_re: 
  
   mov %cl, (%rax,%rsi,1)
inc %rsi
  cmp %rdi, %rbx
    je  end_buffer_stripper_0

    next_bit_strip:    
  	inc %rdi 
    cmp %rdi, %rbx
    jne  strip_loop
    
   ##########################

  mov $0, %rdi
    mov $0, %rsi
    mov $0, %rax
    mov $0, %rbx
    mov $0, %rcx
# _________________________
end_buffer_stripper_0:  
popq  %rbp
    ret 
    
    

#ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸

.globl buffer_comment_0
buffer_comment_0:
 pushq %rbp 
    movq  %rsp, %rbp
    
    mov $BUFFER_DATA, %rax
    mov $BUFFER_SIZE, %rbx
    
    
  mov $0, %rdi
    mov $0, %rsi
    cmp $0, %rbx
    je end_buffer_comment_0
    
 comment_loop:  	# was convert_loop:
    		#will move to external file and do 'nand' 
    		#or do them out of the not gate as tx 
    mov (%rax,%rdi,1), %cl  # lower byte of rcx


  ##########################
     cmpb $'#', %cl 
jne to_buff_com
comment_out_strip:
 mov (%rax,%rdi,1), %cl #â£ï¸leave this, look at it, duh (confused me earlier)
 inc %rdi
 cmpb $10, %cl #ascii for 'n\'
 jne comment_out_strip

cmp %rdi, %rbx
    jne  comment_loop
   # jmp end_buffer_comment_0
  #################

 to_buff_com: 
  
   mov %cl, (%rax,%rsi,1)
inc %rsi


    next_bit_comment:    
  	inc %rdi 
    cmp %rdi, %rbx
    jne  comment_loop
    
   #################
  mov $0, %rdi
    mov $0, %rsi
    mov $0, %rax
    mov $0, %rbx
    mov $0, %rcx
 
# _________________________
end_buffer_comment_0:  
popq  %rbp
    ret 



#ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸
##ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸redoing "nqn" for taking in buffer and looping thr
##ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ make this one easy 2 understand pls.
##ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸stripping it should be seperate fx. then u can still do what u need after
##ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸put many tests in.
.globl buffer_engine_0 
buffer_engine_0: 
 #_________________________
end_buffer_engine_0:  
#ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸ğŸš‚ï¸







#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
















#ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸ğŸª€ï¸




 

#â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸
#â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸
#â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸
#â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸
#â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸
#â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸
#â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸
#â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸â˜ªï¸


#_________________________âš”ï¸
#â˜ªï¸




#ğŸª³ï¸#ğŸª³ï¸#ğŸª³ï¸#ğŸª³ï¸#ğŸª³ï¸#ğŸª³ï¸#ğŸª³ï¸#ğŸª³ï¸

#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸
#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸
#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸
#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸#ğŸ€ï¸



#ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸
#ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸
#ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸#

#ğŸšï¸#
.globl print_err_0  
print_err_0 :
 pushq %rbp 
    movq  %rsp, %rbp

start_print_err_0 :

      
   movq  $err_msg_0, %rsi      #this buffer
movq $err_msg_0_len , %rax

   movq  %rax, %rdx             #buff 2 
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_err_msg_0 :
 popq  %rbp
    ret 
#---------------------------ğŸšï¸
#---------------------------ğŸšï¸

.globl print_buff  
print_buff :
 pushq %rbp 
    movq  %rsp, %rbp

start_print_buff :

      
   movq  $BUFFER_DATA, %rsi      #this buffer
   movq $BUFFER_SIZE, %rax #replace size?
    movq  %rax, %rdx             #buff 2 
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    syscall
    
end_print_buff :
 popq  %rbp
    ret 
#---------------------------ğŸšï¸

#---------------------------ğŸšï¸

.globl print_16
print_16 :
 pushq %rbp 
    movq  %rsp, %rbp

start_print_16 :

      
   movq  $ascii_16_test_0, %rsi      #this buffer
   	
   movq $16, %rax #replace size?

    movq  %rax, %rdx             #buff 2 
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_print_16 :
 popq  %rbp
    ret 
#---------------------------ğŸšï¸




#---------------------------ğŸšï¸

.globl ascii_4_test_out_0   
ascii_4_test_out_0 :
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_4_test_out_0:

      
   movq  $ascii_4_test_0, %rsi      #this buffer
   	
   movq $4, %rax #replace size?

    movq  %rax, %rdx             #buff 2 
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_4_test_out_0 :
 popq  %rbp
    ret 
#---------------------------ğŸšï¸


#---------------------------ğŸšï¸

.globl ascii_4_head_out   
ascii_4_head_out :
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_4_head_out :

      
   movq  $ascii_4_head, %rsi      #this buffer
   	#movq 	ascii_4_a, %rsi #ğŸ’¡ï¸
   movq $4, %rax #replace size?

    movq  %rax, %rdx             #buff 2 
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_4_head_out :
 popq  %rbp
    ret 
#---------------------------ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸

#---------------------------ğŸšï¸

.globl ascii_4_a_out  
ascii_4_a_out :
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_4_a_out :

      
   movq  $ascii_4_a, %rsi      #this buffer
   	#movq 	ascii_4_a, %rsi #ğŸ’¡ï¸
   movq $4, %rax #replace size?

    movq  %rax, %rdx             #buff 2 
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_4_a_out :
 popq  %rbp
    ret 
#---------------------------ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#---------------------------ğŸšï¸

.globl ascii_4_b_out   
ascii_4_b_out :
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_4_b_out :

      
   movq  $ascii_4_b, %rsi      #this buffer
   	#movq 	ascii_4_a, %rsi #ğŸ’¡ï¸
   movq $4, %rax #replace size?

    movq  %rax, %rdx             #buff 2 
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_4_b_out :
 popq  %rbp
    ret 
#---------------------------ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸

#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#---------------------------ğŸšï¸

.globl ascii_4_i_out   
ascii_4_i_out :
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_4_i_out :

      
   movq  $ascii_4_i, %rsi      #this buffer
   	#movq 	ascii_4_a, %rsi #ğŸ’¡ï¸
   movq $4, %rax #replace size?

    movq  %rax, %rdx             #buff 2 
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_4_i_out :
 popq  %rbp
    ret 
#---------------------------ğŸšï¸

#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸



#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#---------------------------ğŸšï¸

.globl ascii_newline 
ascii_newline:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_newline:
#ğŸ‘¨ğŸ½â€âš•ï¸ï¸im gonna diagnose newline by pushing random stuff 2 stack and seeing
#if it messes it up 
#or just printing "ascii's as is...
      
   movq  $newline_out, %rsi      #this buffer
   	
   movq $1, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_newline:
 popq  %rbp
    ret 
#---------------------------ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸

#ram_32_0
 #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
.globl ascii_32_out 
ascii_32_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_32_out:

   movq  $ram_32_0, %rsi      #this buffer
   	
   movq $32, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_32_out:
 popq  %rbp
    ret 
    
    
    
    
    
    
    #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
#---------------------------ğŸšï¸
 #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
.globl ascii_64_out 
ascii_64_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_64_out:
#ğŸ‘¨ğŸ½â€âš•ï¸ï¸im gonna diagnose newline by pushing random stuff 2 stack and seeing
#if it messes it up 
#or just printing "ascii's as is...
      
   movq  $ram_64_0, %rsi      #this buffer
   	
   movq $64, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_64_out:
 popq  %rbp
    ret 
    
    
    
    
    
    
    #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
.globl ascii_64_history_out 
ascii_64_history_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_64_history_out:
#ğŸ‘¨ğŸ½â€âš•ï¸ï¸im gonna diagnose newline by pushing random stuff 2 stack and seeing
#if it messes it up 
#or just printing "ascii's as is...
      
   movq  $ram_64_history_0, %rsi      #this buffer
   	
   movq $64, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_64_history_out:
 popq  %rbp
    ret 
    #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ 
    
    #ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸
               #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
.globl ascii_64_t_out 
ascii_64_t_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_64_t_out:
#ğŸ‘¨ğŸ½â€âš•ï¸ï¸im gonna diagnose newline by pushing random stuff 2 stack and seeing
#if it messes it up 
#or just printing "ascii's as is...
      
   movq  $ram_64_t_0, %rsi      #this buffer
   	
   movq $64, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_64_t_out:
 popq  %rbp
    ret 
    #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ 
    #ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸#ğŸ“ºï¸
    
            #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
.globl ascii_64_v_out 
ascii_64_v_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_64_v_out:
#ğŸ‘¨ğŸ½â€âš•ï¸ï¸im gonna diagnose newline by pushing random stuff 2 stack and seeing
#if it messes it up 
#or just printing "ascii's as is...
      
   movq  $ram_64_v_0, %rsi      #this buffer
   	
   movq $64, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_64_v_out:
 popq  %rbp
    ret 
    #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ 
        #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
.globl ascii_64_v_history_out 
ascii_64_v_history_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_64_v_history_out:
#ğŸ‘¨ğŸ½â€âš•ï¸ï¸im gonna diagnose newline by pushing random stuff 2 stack and seeing
#if it messes it up 
#or just printing "ascii's as is...
      
   movq  $ram_64_v_history_0, %rsi      #this buffer
   	
   movq $64, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_64_v_history_out:
 popq  %rbp
    ret 
    #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ 
    
    
    
     #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
.globl ascii_128_v_out 
ascii_128_v_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_128_v_out:

      
   movq  $ram_128_v_0, %rsi      #this buffer
   	
   movq $128, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_128_v_out:
 popq  %rbp
    ret 
    #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ 
    
#---------------------------ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸

    
     #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
.globl ascii_256_v_out 
ascii_256_v_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_256_v_out:

      
   movq  $ram_256_v_0, %rsi      #this buffer
   	
   movq $256, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_256_v_out:
 popq  %rbp
    ret 
    #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ 
    
#---------------------------ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#---------------------------ğŸšï¸

#---------------------------ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸

    
     #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸
.globl ascii_256_cli_out 
ascii_256_cli_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_256_cli_out:

      
   movq  $ram_256_cli_0, %rsi      #this buffer
   	
   movq $256, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_256_cli_out:
 popq  %rbp
    ret 
    #ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ğŸ–¨ï¸ğŸï¸ 
    
#---------------------------ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#---------------------------ğŸšï¸
#ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸
#https://forum.nasm.us/index.php?topic=98.0 (nasm speaker syscal8)
.globl ascii_sing_out 
ascii_sing_out :
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_sing_out:
      
   movq  $ascii_sing, %rsi      #this buffer
   	
   movq $1, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_sing_out :
 popq  %rbp
    ret 
    
    #ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸ğŸ™ï¸
#---------------------------ğŸšï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#ì—˜ sing test. not gonna work but w/e lets test it. 

#ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸
#https://forum.nasm.us/index.php?topic=98.0 (nasm speaker syscal8)
.globl ascii_sing_test 
ascii_sing_test :
 pushq %rbp 
    movq  %rsp, %rbp

start_ascii_sing_test:
      
   movq  $sing_test, %rsi      #this buffer
   	
   movq $1, %rax #lasttime i checked \n only takes 1 char ;) 

    movq  %rax, %rdx             #buff size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file s
    
    syscall
    
end_ascii_sing_test :
 popq  %rbp
    ret 
#ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸ğŸ™ï¸ğŸ§ªï¸
#------------------------------------ğŸˆºï¸
#sys in . #can still io from ascii so no biggie
.globl sys_in
sys_in:
 pushq %rbp 
    movq  %rsp, %rbp

start_sys_in:

open_files:
open_fd_in:
#
#cmpq $3, ST_ARGC(%rbp) #(use the real position if u want ...duh
#jne store_fd_stdin

  mov $filename_in, %rdi # ğŸš©            
   
    mov $O_RDONLY, %rsi   
      # mov $O_CREAT_WRONLY_TRUNC, %rsi
      
    mov $0666, %rdx                    
    mov $SYS_OPEN, %rax 

    syscall #ğŸ•ï¸
store_fd_in:
    #save the given file descriptor
    movq  %rax, ST_FD_IN(%rbp)
    

  #--------------------
    jmp end_sys_in # open_fd_out
    
    store_fd_stdin:
#save the given file descriptor
movl $STDIN, ST_FD_IN(%rbp)

end_sys_in:
 popq  %rbp
    ret 
#---------------------------ğŸˆºï¸
#ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸ğŸšï¸
#--------------------------------------ğŸ›ï¸

.globl sys_out
sys_out:
 pushq %rbp 
    movq  %rsp, %rbp

start_sys_out:

  open_fd_out:
 
cmpq $3, ST_ARGC(%rbp)  #will auto jump unless 3 args (aren't (maynot even do that anywas lol)
jne store_fd_stdout

###OPEN OUTPUT FILE###
    movq  $SYS_OPEN, %rax          #open 
    movq  ST_ARGV_2(%rbp), %rdi    #this file
    movq  $O_CREAT_WRONLY_TRUNC, %rsi          #with write_only flag
    movq  $0666, %rdx              #(if needed creation) with mode 666
    syscall                        #file id returned in %rax
store_fd_out:
    #store the file descriptor here
    movq  %rax, ST_FD_OUT(%rbp)
 
    jmp  end_sys_out #read_loop_begin  #ğŸ€„ï¸ 
    
    store_fd_stdout:
#store the file descriptor here
movl $STDOUT, ST_FD_OUT(%rbp)
end_sys_out:

 popq  %rbp
    ret 

#---------------------------------------ğŸšï¸
#ğŸ“¥ï¸â˜ï¸ğŸ“¥ï¸â˜ï¸ğŸ“¥ï¸â˜ï¸
#
.globl modem_open
modem_open:
 pushq %rbp 
    movq  %rsp, %rbp

start_modem_open:
#â˜ï¸
 mov $modem_filename_in, %rdi #ğŸš©   ##ğŸ›ï¸ ğŸ”›address of output filename]ON
   mov $O_RDONLY, %rsi   
      # mov $O_CREAT_WRONLY_TRUNC, %rsi
    mov $0666, %rdx                    
    mov $SYS_OPEN, %rax 

    syscall #ğŸ•ï¸

wrap_modem_open:
    mov %rax, modem_in_stack_pos(%rbp)  #file addr...(not data)
    					#data will LOAD in $test_DATA
#â˜ï¸
 end_modem_open:
 popq  %rbp
    ret 
    
  #â—ï¸done? NOW DO > THIS>     .globl load_buff
    #â—ï¸(u may as well remove comments / spaces HOWEVER
     #â—ï¸u will probably want "NEW FX FOR THAT (cuz name , w/e tho) 
     # at least at first
#ğŸ“¥ï¸â˜ï¸ğŸ“¥ï¸â˜ï¸ğŸ“¥ï¸â˜ï¸  
#ğŸ“¥ï¸â˜ï¸ğŸ“¥ï¸â˜ï¸ğŸ“¥ï¸â˜ï¸     

.globl load_buff_modem  #called continue but call from "MAIN" same as 123
load_buff_modem:
 pushq %rbp 
    movq  %rsp, %rbp

start_load_buff_modem:
# ğŸ•¹ï¸
###BEGIN MAIN LOOP###
modem_load_loop_begin_0:
    ###READ IN A BLOCK FROM THE INPUT FILE###
    movq  $SYS_READ, %rax       #read
    movq  modem_in_stack_pos(%rbp), %rdi  #from this file
    movq  $BUFFER_DATA, %rsi    #to this buffer
    movq  $BUFFER_SIZE, %rdx    #up to this count
    syscall                     #size of buffer read is returned in %rax
    
    ###EXIT IF WEâ€™VE REACHED THE END###
    #check for end of file marker
    cmpq  $END_OF_FILE, %rax
    #if found or on error, go to the end
    jle   end_load_buff # end_loop
    
    modem_continue_load_loop_0:
###CONVERT THE BLOCK TO UPPER CASE###
    movq $BUFFER_DATA, %rdi    #location of buffer #
    #jul]13 < dont think we need ^ but im doing modem dont wanna break
# ğŸ•¹ï¸
    movq %rax, %rsi            #size of the buffer ###ğŸ•¹ï¸
 
#ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]

end_load_buff_modem:
 popq  %rbp
    ret 

#ğŸ“¥ï¸â˜ï¸ğŸ“¥ï¸â˜ï¸ğŸ“¥ï¸â˜ï¸   

#i dont think u have 2 keep re putting "MODEM IN addr into var"
#but w/e 
#i do think ur gonna want to open only specific "PORTS"
#so u may be right 2 do in fx and change "mov $logname_out, %rdi #ğŸš© "
#depending , (may even make ur own "string_#18+.txt" for each log addr

#ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸
.globl modem_out_open
modem_out_open:
 pushq %rbp 
    movq  %rsp, %rbp


 popq  %rbp
    ret 

#ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸ğŸ“¤ï¸â˜ï¸

#ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸
#save_state_open
#save_state_load

#load_state_open
#load_state_load
#ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸ğŸ’¾ï¸


#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸
.globl log_open
log_open:
 pushq %rbp 
    movq  %rsp, %rbp

start_log_open:
	#sameV
 mov $logname_out, %rdi #ğŸš©   ##ğŸ›ï¸ ğŸ”›address of output filename]ON
    mov $0666, %rdx                     # perms
    mov $0x441, %rsi  #tweak this (append+ (for better performance.
    #https://stackoverflow.com/questions/48541868/how-to-append-to-a-file-using-x86-64-linux-system-calls
    mov $SYS_OPEN, %rax #ğŸš© #ğŸ’° file addr stored in rax after syscall
    syscall #ğŸ•ï¸
    
    mov %rax, ST_LOG_OUT_0(%rbp)  #file addr...(not data)
  
 # mov %rax, ST_LOG_OUT_1(%rbp)
    
    end_log_open:
 popq  %rbp
    ret 

#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸
.globl log_out
log_out:
 pushq %rbp 
    movq  %rsp, %rbp
    
    
       start_log_out: 

  #  mov  $newline_out , %rsi      #this buffer 
  #  movq  $1, %rdx             #buff size
  #  movq  $SYS_WRITE, %rax        #write to
    movq  ST_LOG_OUT_0(%rbp), %rdi   #to this file s   
  #  syscall
   
end_log_out:
 popq  %rbp
    ret 
#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸
#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸#ğŸ–¨ï¸



#ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸
#ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸
#ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸ğŸ§Šï¸

#------------------------------------ğŸ›ï¸
.globl load_buff  #called continue but call from "MAIN" same as 123
load_buff:
 pushq %rbp 
    movq  %rsp, %rbp

start_load_buff:
# ğŸ•¹ï¸
###BEGIN MAIN LOOP###
load_loop_begin_0:
    ###READ IN A BLOCK FROM THE INPUT FILE###
    movq  $SYS_READ, %rax       #read
    movq  ST_FD_IN(%rbp), %rdi  #from this file
    movq  $BUFFER_DATA, %rsi    #to this buffer
    movq  $BUFFER_SIZE, %rdx    #up to this count
    syscall                     #size of buffer read is returned in %rax
    
    ###EXIT IF WEâ€™VE REACHED THE END###
    #check for end of file marker
    cmpq  $END_OF_FILE, %rax
    #if found or on error, go to the end
    jle   end_load_buff # end_loop
    
    continue_load_loop_0:
###CONVERT THE BLOCK TO UPPER CASE###
    movq $BUFFER_DATA, %rdi    #location of buffer #
    #jul]13 < dont think we need ^ but im doing modem dont wanna break
# ğŸ•¹ï¸
    movq %rax, %rsi            #size of the buffer ###ğŸ•¹ï¸
 
#ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]ğŸ¥¼ï¸]

end_load_buff:
 popq  %rbp
    ret 
#---------------------------ğŸšï¸


#ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸SP.FARMING THEORY = SUPREMEğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸>the fact that this NOS STUFF DOESN"T "MATTER" 
#and that u could even "LOSE SOLPEN" w/o losing the understandings of it 
#IS A GOOD THINGP{but dont...}}
#{>pin}? i think (like ~v~) thse things are "spirituall 'from sp" but dont 'rap/deplete its core
#they actually enrich >pin and "self sustain it. for movies or w/e i think nugget drops of core 
#beats should be like breadcrums and most importantly u should always legally protect IP test waters cuz its meeting reality 
#example using clones dosen't have 2 relate  2 >pin anymore than star wars (but it DOES)
#and cloning is more inportant than ent we already have engt somewere and it can infinitely 
#spin off multiverses that can actually disapear w/o harming core....

#example i really think this "Nugget" if understood is "MOR IMPORTANT" than sp itself
#4 the survival of "SP" (legallly etc) and i can just drop it at the bottom of pages etc...
#also this using "SP as GOL SETTING , is more important than ent as well imo
# = ğŸŒŠï¸ğŸŒï¸    ğŸŒ›ï¸ğŸ’ï¸ğŸŒï¸ğŸ›°ï¸ğŸ•Œï¸ğŸ±ï¸ğŸ•¸ï¸ğŸªï¸â›©ï¸âŒšï¸ğŸ©ï¸ğŸ”ï¸~
#ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸ğŸ”ï¸

 
  
